<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>Module: Innate::Node</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <meta http-equiv="Content-Script-Type" content="text/javascript" />
  <link rel="stylesheet" href="../.././rdoc-style.css" type="text/css" media="screen" />
  <script type="text/javascript">
  // <![CDATA[

  function popupCode( url ) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;
    
    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  
  // Make codeblocks hidden by default
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }</style>" )
  
  // ]]>
  </script>

</head>
<body>



    <div id="classHeader">
        <table class="header-table">
        <tr class="top-aligned-row">
          <td><strong>Module</strong></td>
          <td class="class-name-in-header">Innate::Node</td>
        </tr>
        <tr class="top-aligned-row">
            <td><strong>In:</strong></td>
            <td>
                <a href="../../files/lib/innate/node_rb.html">
                lib/innate/node.rb
                </a>
        <br />
            </td>
        </tr>

        </table>
    </div>
  <!-- banner header -->

  <div id="bodyContent">



  <div id="contextContent">

    <div id="description">
      <p>
The nervous system of {<a href="../Innate.html">Innate</a>}, so you can
relax.
</p>
<p>
<a href="Node.html">Node</a> may be <a
href="Node.html#M000412">included</a> into any class to make it a valid
responder to requests.
</p>
<p>
The major difference between this and the old Ramaze controller is that
every <a href="Node.html">Node</a> acts as a standalone application with
its own dispatcher.
</p>
<p>
What&#8216;s also an important difference is the fact that {<a
href="Node.html">Node</a>} is a module, so we don&#8216;t have to spend a
lot of time designing the perfect subclassing scheme.
</p>
<p>
This makes dispatching more fun, avoids a lot of processing that is done by
{Rack} anyway and lets you tailor your application down to the last action
exactly the way you want without worrying about side-effects to other {<a
href="Node.html">Node</a>}s.
</p>
<p>
Upon inclusion, it will also include {<a
href="Trinity.html">Innate::Trinity</a>} and {<a
href="Helper.html">Innate::Helper</a>} to <a
href="Node.html#M000417">provide</a> you with {<a
href="Request.html">Innate::Request</a>}, {<a
href="Response.html">Innate::Response</a>}, {<a
href="Session.html">Innate::Session</a>} instances, and all the standard
helper methods as well as the ability to simply add other helpers.
</p>
<p>
Please note that method_missing will <em>not</em> be considered when
building an {<a href="Action.html">Action</a>}. There might be future
demand for this, but for now you can simply use `def index(*args); end` to
make a catch-all action.
</p>

    </div>


   </div>

    <div id="method-list">
      <h3 class="section-bar">Methods</h3>

      <div class="name-list">
      <a href="#M000421">action_found</a>&nbsp;&nbsp;
      <a href="#M000422">action_missing</a>&nbsp;&nbsp;
      <a href="#M000431">alias_view</a>&nbsp;&nbsp;
      <a href="#M000443">binding</a>&nbsp;&nbsp;
      <a href="#M000419">call</a>&nbsp;&nbsp;
      <a href="#M000425">fill_action</a>&nbsp;&nbsp;
      <a href="#M000432">find_aliased_view</a>&nbsp;&nbsp;
      <a href="#M000426">find_layout</a>&nbsp;&nbsp;
      <a href="#M000427">find_method</a>&nbsp;&nbsp;
      <a href="#M000424">find_provide</a>&nbsp;&nbsp;
      <a href="#M000429">find_view</a>&nbsp;&nbsp;
      <a href="#M000414">generate_mapping</a>&nbsp;&nbsp;
      <a href="#M000412">included</a>&nbsp;&nbsp;
      <a href="#M000434">layout</a>&nbsp;&nbsp;
      <a href="#M000448">layout_mappings</a>&nbsp;&nbsp;
      <a href="#M000416">map</a>&nbsp;&nbsp;
      <a href="#M000447">map_layouts</a>&nbsp;&nbsp;
      <a href="#M000445">map_views</a>&nbsp;&nbsp;
      <a href="#M000415">mapping</a>&nbsp;&nbsp;
      <a href="#M000450">needs_method?</a>&nbsp;&nbsp;
      <a href="#M000449">options</a>&nbsp;&nbsp;
      <a href="#M000435">patterns_for</a>&nbsp;&nbsp;
      <a href="#M000442">possible_exts_for</a>&nbsp;&nbsp;
      <a href="#M000441">possible_paths_for</a>&nbsp;&nbsp;
      <a href="#M000417">provide</a>&nbsp;&nbsp;
      <a href="#M000451">provide_set?</a>&nbsp;&nbsp;
      <a href="#M000418">provides</a>&nbsp;&nbsp;
      <a href="#M000423">resolve</a>&nbsp;&nbsp;
      <a href="#M000444">root_mappings</a>&nbsp;&nbsp;
      <a href="#M000413">setup</a>&nbsp;&nbsp;
      <a href="#M000433">to_layout</a>&nbsp;&nbsp;
      <a href="#M000436">to_template</a>&nbsp;&nbsp;
      <a href="#M000430">to_view</a>&nbsp;&nbsp;
      <a href="#M000420">try_resolve</a>&nbsp;&nbsp;
      <a href="#M000439">update_layout_mappings</a>&nbsp;&nbsp;
      <a href="#M000440">update_mapping_shared</a>&nbsp;&nbsp;
      <a href="#M000428">update_method_arities</a>&nbsp;&nbsp;
      <a href="#M000437">update_template_mappings</a>&nbsp;&nbsp;
      <a href="#M000438">update_view_mappings</a>&nbsp;&nbsp;
      <a href="#M000446">view_mappings</a>&nbsp;&nbsp;
      </div>
    </div>

  </div>


    <!-- if includes -->
    <div id="includes">
      <h3 class="section-bar">Included Modules</h3>

      <div id="includes-list">
        <span class="include-name"><a href="Traited.html">Traited</a></span>
      </div>
    </div>

    <div id="section">


    <div id="constants-list">
      <h3 class="section-bar">Constants</h3>

      <div class="name-list">
        <table summary="Constants">
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">NODE_LIST</td>
          <td>=</td>
          <td class="context-item-value">Set.new</td>
        </tr>
        </table>
      </div>
    </div>



    <div id="attribute-list">
      <h3 class="section-bar">Attributes</h3>

      <div class="name-list">
        <table>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">layout_templates</td>
          <td class="context-item-value">&nbsp;[R]&nbsp;</td>
          <td class="context-item-desc"></td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">method_arities</td>
          <td class="context-item-value">&nbsp;[R]&nbsp;</td>
          <td class="context-item-desc"></td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">view_templates</td>
          <td class="context-item-value">&nbsp;[R]&nbsp;</td>
          <td class="context-item-desc"></td>
        </tr>
        </table>
      </div>
    </div>
      


    <!-- if method_list -->
    <div id="methods">
      <h3 class="section-bar">Public Class methods</h3>

      <div id="method-M000414" class="method-detail">
        <a name="M000414"></a>

        <div class="method-heading">
          <a href="Node.src/M000414.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000414.html');return false;">
          <span class="method-name">generate_mapping</span><span class="method-args">(object_name = self.name)</span>
          </a>
        </div>
      
        <div class="method-description">
        </div>
      </div>

      <div id="method-M000412" class="method-detail">
        <a name="M000412"></a>

        <div class="method-heading">
          <a href="Node.src/M000412.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000412.html');return false;">
          <span class="method-name">included</span><span class="method-args">(into)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Upon inclusion we make ourselves comfortable.
</p>
        </div>
      </div>

      <div id="method-M000413" class="method-detail">
        <a name="M000413"></a>

        <div class="method-heading">
          <a href="Node.src/M000413.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000413.html');return false;">
          <span class="method-name">setup</span><span class="method-args">()</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
node <a href="Node.html#M000415">mapping</a> procedure
</p>
<p>
when <a href="Node.html">Node</a> is <a
href="Node.html#M000412">included</a> into an object, it&#8216;s added to
NODE_LIST when object::<a href="Node.html#M000416">map</a>(location) is
sent, it maps the object into DynaMap when Innate.start is issued, it calls
Node::setup Node::setup iterates NODE_LIST and maps all objects not in
DynaMap by using Node::generate_mapping(object.name) as location
</p>
<p>
when object::<a href="Node.html#M000416">map</a>(nil) is sent, the object
will be skipped in Node::setup
</p>
        </div>
      </div>

      <h3 class="section-bar">Public Instance methods</h3>

      <div id="method-M000421" class="method-detail">
        <a name="M000421"></a>

        <div class="method-heading">
          <a href="Node.src/M000421.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000421.html');return false;">
          <span class="method-name">action_found</span><span class="method-args">(action)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Executed once an {<a href="Action.html">Action</a>} has been found.
</p>
<p>
Reset the {<a href="Response.html">Innate::Response</a>} instance, catch
:respond and :redirect. {<a href="Action.html#M000574">Action#call</a>} has
to return a String.
</p>
<p>
@param [<a href="Action.html">Action</a>] action
</p>
<p>
@return [<a href="Response.html">Innate::Response</a>]
</p>
<p>
@api external @see <a href="Action.html#M000574">Action#call</a> <a
href="Response.html">Innate::Response</a> @author manveru
</p>
        </div>
      </div>

      <div id="method-M000422" class="method-detail">
        <a name="M000422"></a>

        <div class="method-heading">
          <a href="Node.src/M000422.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000422.html');return false;">
          <span class="method-name">action_missing</span><span class="method-args">(path)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
The default handler in case no action was found, kind of method_missing.
Must modify the response in order to have any lasting effect.
</p>
<p>
Reasoning:
</p>
<ul>
<li>We are doing this is in order to avoid tons of special error handling code
that would impact runtime and make the overall API more complicated.

</li>
<li>This cannot be a normal action is that methods defined in {<a
href="Node.html">Innate::Node</a>} will never be considered for actions.

</li>
</ul>
<p>
To use a normal action with template do following:
</p>
<p>
@example
</p>
<pre>
  class Hi
    include Innate::Node
    map '/'

    def self.action_missing(path)
      return if path == '/not_found'
      # No normal action, runs on bare metal
      try_resolve('/not_found')
    end

    def not_found
      # Normal action
      &quot;Sorry, I do not exist&quot;
    end
  end
</pre>
<p>
@param [String] path
</p>
<p>
@api external @see <a href="Response.html">Innate::Response</a> <a
href="Node.html#M000420">Node#try_resolve</a> @author manveru
</p>
        </div>
      </div>

      <div id="method-M000431" class="method-detail">
        <a name="M000431"></a>

        <div class="method-heading">
          <a href="Node.src/M000431.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000431.html');return false;">
          <span class="method-name">alias_view</span><span class="method-args">(to, from, node = nil)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Aliasing one view from another. The aliases are inherited, and the optional
third <tt>node</tt> parameter indicates the <a href="Node.html">Node</a> to
take the view from.
</p>
<p>
The argument order is identical with `alias` and `alias_method`, which
quite honestly confuses me, but at least we stay consistent.
</p>
<p>
@example
</p>
<pre>
  class Foo
    include Innate::Node

    # Use the 'foo' view when calling 'bar'
    alias_view 'bar', 'foo'

    # Use the 'foo' view from FooBar node when calling 'bar'
    alias_view 'bar', 'foo', FooBar
  end
</pre>
<p>
Note that the parameters have been simplified in comparision with
Ramaze::Controller::template where the second parameter may be a Controller
or the name of the template. We take that now as an optional third
parameter.
</p>
<p>
@param [to_s] to view that should be replaced @param [to_s] from view to
use or <a href="Node.html">Node</a>. @param [nil?, <a
href="Node.html">Node</a>] node optionally obtain view from this <a
href="Node.html">Node</a>
</p>
<p>
@api external @see Node::find_aliased_view @author manveru
</p>
        </div>
      </div>

      <div id="method-M000443" class="method-detail">
        <a name="M000443"></a>

        <div class="method-heading">
          <a href="Node.src/M000443.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000443.html');return false;">
          <span class="method-name">binding</span><span class="method-args">()</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
For compatibility with new Kernel#binding behaviour in 1.9
</p>
<p>
@return [Binding] <a href="Node.html#M000443">binding</a> of the instance
being rendered. @see <a href="Action.html#M000575">Action#binding</a>
@author manveru
</p>
        </div>
      </div>

      <div id="method-M000419" class="method-detail">
        <a name="M000419"></a>

        <div class="method-heading">
          <a href="Node.src/M000419.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000419.html');return false;">
          <span class="method-name">call</span><span class="method-args">(env)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
This makes the <a href="Node.html">Node</a> a valid application for Rack.
<tt>env</tt> is the environment hash passed from the Rack::Handler
</p>
<p>
We rely on correct PATH_INFO.
</p>
<p>
As defined by the Rack spec, PATH_INFO may be empty if it wants the root of
the application, so we insert &#8217;/&#8217; to make our dispatcher
simple.
</p>
<p>
<a href="../Innate.html">Innate</a> will not rescue any errors for you or
do any error handling, this should be done by an underlying middleware.
</p>
<p>
We do however log errors at some vital points in order to <a
href="Node.html#M000417">provide</a> you with feedback in your logs.
</p>
<p>
A lot of functionality in here relies on the fact that <a
href="Node.html#M000419">call</a> is executed within <a
href="Current.html#M000564">Current#call</a> which populates the variables
used by <a href="Trinity.html">Trinity</a>. So if you use the <a
href="Node.html">Node</a> directly as a middleware make sure that you use
<a href="Current.html">Innate::Current</a> as a middleware before it.
</p>
<p>
@param [Hash] env
</p>
<p>
@return [Array]
</p>
<p>
@api external @see <a href="Response.html#M000514">Response#reset</a> <a
href="Node.html#M000420">Node#try_resolve</a> <a
href="Session.html#M000464">Session#flush</a> @author manveru
</p>
        </div>
      </div>

      <div id="method-M000425" class="method-detail">
        <a name="M000425"></a>

        <div class="method-heading">
          <a href="Node.src/M000425.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000425.html');return false;">
          <span class="method-name">fill_action</span><span class="method-args">(action, given_name)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Now we&#8216;re talking {<a href="Action.html">Action</a>}, we try to find
a matching template and method, if we can&#8216;t find either we go to the
next pattern, otherwise we answer with an {<a
href="Action.html">Action</a>} with everything we know so far about the
demands of the client.
</p>
<p>
@param [String] given_name the name extracted from REQUEST_PATH @param
[String] wish
</p>
<p>
@return [<a href="Action.html">Action</a>, nil]
</p>
<p>
@api internal @see <a href="Node.html#M000427">Node#find_method</a> <a
href="Node.html#M000429">Node#find_view</a> <a
href="Node.html#M000426">Node#find_layout</a> <a
href="Node.html#M000435">Node#patterns_for</a>
</p>
<pre>
     Action#wish Action#merge!
</pre>
<p>
@author manveru
</p>
        </div>
      </div>

      <div id="method-M000432" class="method-detail">
        <a name="M000432"></a>

        <div class="method-heading">
          <a href="Node.src/M000432.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000432.html');return false;">
          <span class="method-name">find_aliased_view</span><span class="method-args">(action_name, wish)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Resolve one level of aliasing for the given <tt>action_name</tt> and
<tt>wish</tt>.
</p>
<p>
@param [String] action_name @param [String] wish
</p>
<p>
@return [nil, String] the absolute path to the aliased template or nil
</p>
<p>
@api internal @see Node::alias_view Node::find_view @author manveru
</p>
        </div>
      </div>

      <div id="method-M000426" class="method-detail">
        <a name="M000426"></a>

        <div class="method-heading">
          <a href="Node.src/M000426.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000426.html');return false;">
          <span class="method-name">find_layout</span><span class="method-args">(name, wish)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Try to find a suitable value for the <a
href="Node.html#M000434">layout</a>. This may be a template or the name of
a method.
</p>
<p>
If a <a href="Node.html#M000434">layout</a> could be found, an Array with
two elements is returned, the first indicating the kind of <a
href="Node.html#M000434">layout</a> (:<a
href="Node.html#M000434">layout</a>|:view|:method), the second the found
value, which may be a String or Symbol.
</p>
<p>
@param [String] name @param [String] wish
</p>
<p>
@return [Array, nil]
</p>
<p>
@api external @see <a href="Node.html#M000433">Node#to_layout</a> <a
href="Node.html#M000427">Node#find_method</a> <a
href="Node.html#M000429">Node#find_view</a> @author manveru
</p>
<p>
@todo allow layouts combined of method and view&#8230; hairy :)
</p>
        </div>
      </div>

      <div id="method-M000427" class="method-detail">
        <a name="M000427"></a>

        <div class="method-heading">
          <a href="Node.src/M000427.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000427.html');return false;">
          <span class="method-name">find_method</span><span class="method-args">(name, params)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
We check arity if possible, but will happily dispatch to any method that
has default parameters. If you don&#8216;t want your method to be
responsible for messing up a request you should think twice about the
arguments you specify due to limitations in Ruby.
</p>
<p>
So if you want your method to take only one parameter which may have a
default value following will work fine:
</p>
<pre>
  def index(foo = &quot;bar&quot;, *rest)
</pre>
<p>
But following will respond to /arg1/arg2 and then fail due to
ArgumentError:
</p>
<pre>
  def index(foo = &quot;bar&quot;)
</pre>
<p>
Here a glance at how parameters are expressed in arity:
</p>
<pre>
  def index(a)                  # =&gt; 1
  def index(a = :a)             # =&gt; -1
  def index(a, *r)              # =&gt; -2
  def index(a = :a, *r)         # =&gt; -1

  def index(a, b)               # =&gt; 2
  def index(a, b, *r)           # =&gt; -3
  def index(a, b = :b)          # =&gt; -2
  def index(a, b = :b, *r)      # =&gt; -2

  def index(a = :a, b = :b)     # =&gt; -1
  def index(a = :a, b = :b, *r) # =&gt; -1
</pre>
<p>
@param [String, Symbol] name @param [Array] params
</p>
<p>
@return [String, Symbol]
</p>
<p>
@api external @see <a href="Node.html#M000425">Node#fill_action</a> <a
href="Node.html#M000426">Node#find_layout</a> @author manveru
</p>
<p>
@todo Once 1.9 is mainstream we can use Method#parameters to do accurate
</p>
<pre>
      prediction
</pre>
        </div>
      </div>

      <div id="method-M000424" class="method-detail">
        <a name="M000424"></a>

        <div class="method-heading">
          <a href="Node.src/M000424.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000424.html');return false;">
          <span class="method-name">find_provide</span><span class="method-args">(path)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Resolve possible <a href="Node.html#M000418">provides</a> for the given
<tt>path</tt> from {<a href="Node.html#M000418">provides</a>}.
</p>
<p>
@param [String] path
</p>
<p>
@return [Array] with name, wish, engine
</p>
<p>
@api internal @see Node::provide Node::provides @author manveru
</p>
        </div>
      </div>

      <div id="method-M000429" class="method-detail">
        <a name="M000429"></a>

        <div class="method-heading">
          <a href="Node.src/M000429.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000429.html');return false;">
          <span class="method-name">find_view</span><span class="method-args">(action_name, wish)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Try to find the best template for the given basename and wish and respect
aliased views.
</p>
<p>
@param [to_s] action_name @param [to_s] wish
</p>
<p>
@return [String, nil] depending whether a template could be found
</p>
<p>
@api external @see <a href="Node.html#M000436">Node#to_template</a> <a
href="Node.html#M000432">Node#find_aliased_view</a> @author manveru
</p>
        </div>
      </div>

      <div id="method-M000434" class="method-detail">
        <a name="M000434"></a>

        <div class="method-heading">
          <a href="Node.src/M000434.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000434.html');return false;">
          <span class="method-name">layout</span><span class="method-args">(layout_name = nil, &amp;block)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Define a <a href="Node.html#M000434">layout</a> to use on this <a
href="Node.html">Node</a>.
</p>
<p>
A <a href="Node.html">Node</a> can only have one <a
href="Node.html#M000434">layout</a>, although the template being chosen can
depend on {<a href="Node.html#M000418">provides</a>}.
</p>
<p>
@param [String, to_s] name basename without extension of the <a
href="Node.html#M000434">layout</a> to use @param [Proc, <a
href="Node.html#M000419">call</a>] block called on every dispatch if no
name given
</p>
<p>
@return [Proc, String] The assigned name or block
</p>
<p>
@api external @see <a href="Node.html#M000426">Node#find_layout</a>
Node#layout_paths <a href="Node.html#M000433">Node#to_layout</a>
Node#app_layout @author manveru
</p>
<p>
NOTE:
</p>
<pre>
  The behaviour of Node#layout changed significantly from Ramaze, instead
  of multitudes of obscure options and methods like deny_layout we simply
  take a block and use the returned value as the name for the layout. No
  layout will be used if the block returns nil.
</pre>
        </div>
      </div>

      <div id="method-M000448" class="method-detail">
        <a name="M000448"></a>

        <div class="method-heading">
          <a href="Node.src/M000448.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000448.html');return false;">
          <span class="method-name">layout_mappings</span><span class="method-args">()</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Combine Innate.options.layouts with either the `ancestral_trait[:layouts]`
or the {<a href="Node.html#M000415">Node#mapping</a>} if the trait yields
an empty Array.
</p>
<p>
@return [Array&lt;String&gt;, Array&lt;Array&lt;String&gt;&gt;]
</p>
<p>
@api external @see {<a href="Node.html#M000447">Node#map_layouts</a>}
@author manveru
</p>
        </div>
      </div>

      <div id="method-M000416" class="method-detail">
        <a name="M000416"></a>

        <div class="method-heading">
          <a href="Node.src/M000416.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000416.html');return false;">
          <span class="method-name">map</span><span class="method-args">(location)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Shortcut to <a href="Node.html#M000416">map</a> or remap this <a
href="Node.html">Node</a>.
</p>
<p>
@example Usage for explicit <a href="Node.html#M000415">mapping</a>:
</p>
<pre>
  class FooBar
    include Innate::Node
    map '/foo_bar'
  end

  Innate.to(FooBar) # =&gt; '/foo_bar'
</pre>
<p>
@example Usage for automatic <a href="Node.html#M000415">mapping</a>:
</p>
<pre>
  class FooBar
    include Innate::Node
    map mapping
  end

  Innate.to(FooBar) # =&gt; '/foo_bar'
</pre>
<p>
@param [to_s] location
</p>
<p>
@api external @see Innate::SingletonMethods::map @author manveru
</p>
        </div>
      </div>

      <div id="method-M000447" class="method-detail">
        <a name="M000447"></a>

        <div class="method-heading">
          <a href="Node.src/M000447.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000447.html');return false;">
          <span class="method-name">map_layouts</span><span class="method-args">(*locations)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Set the paths for lookup below the Innate.options.layouts paths.
</p>
<p>
@param [String, Array&lt;String&gt;] locations
</p>
<pre>
  Any number of strings indicating the paths where layout templates may
  be located, relative to Innate.options.roots/Innate.options.layouts
</pre>
<p>
@return [<a href="Node.html">Node</a>] self
</p>
<p>
@api external @see {<a href="Node.html#M000448">Node#layout_mappings</a>}
@author manveru
</p>
        </div>
      </div>

      <div id="method-M000445" class="method-detail">
        <a name="M000445"></a>

        <div class="method-heading">
          <a href="Node.src/M000445.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000445.html');return false;">
          <span class="method-name">map_views</span><span class="method-args">(*locations)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Set the paths for lookup below the Innate.options.views paths.
</p>
<p>
@param [String, Array&lt;String&gt;] locations
</p>
<pre>
  Any number of strings indicating the paths where view templates may be
  located, relative to Innate.options.roots/Innate.options.views
</pre>
<p>
@return [<a href="Node.html">Node</a>] self
</p>
<p>
@api external @see {<a href="Node.html#M000446">Node#view_mappings</a>}
@author manveru
</p>
        </div>
      </div>

      <div id="method-M000415" class="method-detail">
        <a name="M000415"></a>

        <div class="method-heading">
          <a href="Node.src/M000415.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000415.html');return false;">
          <span class="method-name">mapping</span><span class="method-args">()</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Tries to find the relative url that this {<a href="Node.html">Node</a>} is
mapped to. If it cannot find one it will instead generate one based on the
snake_cased name of itself.
</p>
<p>
@example Usage:
</p>
<pre>
  class FooBar
    include Innate::Node
  end
  FooBar.mapping # =&gt; '/foo_bar'
</pre>
<p>
@return [String] the relative path to the node
</p>
<p>
@api external @see <a
href="SingletonMethods.html#M000338">Innate::SingletonMethods#to</a>
@author manveru
</p>
        </div>
      </div>

      <div id="method-M000450" class="method-detail">
        <a name="M000450"></a>

        <div class="method-heading">
          <a href="Node.src/M000450.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000450.html');return false;">
          <span class="method-name">needs_method?</span><span class="method-args">()</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Whether an {<a href="Action.html">Action</a>} can be built without a
method.
</p>
<p>
The default is to allow actions that use only a view template, but you
might want to turn this on, for example if you have partials in your view
directories.
</p>
<p>
@example turning <a href="Node.html#M000450">needs_method?</a> on
</p>
<pre>
  class Foo
    Innate.node('/')
  end

  Foo.needs_method? # =&gt; true
  Foo.trait :needs_method =&gt; false
  Foo.needs_method? # =&gt; false
</pre>
<p>
@return [true, false] (false)
</p>
<p>
@api external @see {<a href="Node.html#M000425">Node#fill_action</a>}
@author manveru
</p>
        </div>
      </div>

      <div id="method-M000449" class="method-detail">
        <a name="M000449"></a>

        <div class="method-heading">
          <a href="Node.src/M000449.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000449.html');return false;">
          <span class="method-name">options</span><span class="method-args">()</span>
          </a>
        </div>
      
        <div class="method-description">
        </div>
      </div>

      <div id="method-M000435" class="method-detail">
        <a name="M000435"></a>

        <div class="method-heading">
          <a href="Node.src/M000435.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000435.html');return false;">
          <span class="method-name">patterns_for</span><span class="method-args">(path) {|action_name, params| ...}</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
The innate beauty in Nitro, Ramaze, and {<a
href="../Innate.html">Innate</a>}.
</p>
<p>
Will yield the name of the action and parameter for the action method in
order of significance.
</p>
<pre>
  def foo__bar # responds to /foo/bar
  def foo(bar) # also responds to /foo/bar
</pre>
<p>
But foo__bar takes precedence because it&#8216;s more explicit.
</p>
<p>
The last fallback will always be the index action with all of the path
turned into parameters.
</p>
<p>
@example yielding possible combinations of action names and params
</p>
<pre>
  class Foo; include Innate::Node; map '/'; end

  Foo.patterns_for('/'){|action, params| p action =&gt; params }
  # =&gt; {&quot;index&quot;=&gt;[]}

  Foo.patterns_for('/foo/bar'){|action, params| p action =&gt; params }
  # =&gt; {&quot;foo__bar&quot;=&gt;[]}
  # =&gt; {&quot;foo&quot;=&gt;[&quot;bar&quot;]}
  # =&gt; {&quot;index&quot;=&gt;[&quot;foo&quot;, &quot;bar&quot;]}

  Foo.patterns_for('/foo/bar/baz'){|action, params| p action =&gt; params }
  # =&gt; {&quot;foo__bar__baz&quot;=&gt;[]}
  # =&gt; {&quot;foo__bar&quot;=&gt;[&quot;baz&quot;]}
  # =&gt; {&quot;foo&quot;=&gt;[&quot;bar&quot;, &quot;baz&quot;]}
  # =&gt; {&quot;index&quot;=&gt;[&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;]}
</pre>
<p>
@param [String, split] path usually the PATH_INFO
</p>
<p>
@return [<a href="Action.html">Action</a>] it actually returns the first
non-nil/false result of yield
</p>
<p>
@api internal @see <a href="Node.html#M000425">Node#fill_action</a> @author
manveru
</p>
        </div>
      </div>

      <div id="method-M000442" class="method-detail">
        <a name="M000442"></a>

        <div class="method-heading">
          <a href="Node.src/M000442.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000442.html');return false;">
          <span class="method-name">possible_exts_for</span><span class="method-args">(wish)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Answer with an array of possible extensions in order of significance for
the given <tt>wish</tt>.
</p>
<p>
@param [to_s] wish the extension (no leading &#8217;.&#8217;)
</p>
<p>
@return [Array] list of exts valid for this <tt>wish</tt>
</p>
<p>
@api internal @see <a href="Node.html#M000436">Node#to_template</a>
View::exts_of <a href="Node.html#M000418">Node#provides</a> @author manveru
</p>
        </div>
      </div>

      <div id="method-M000441" class="method-detail">
        <a name="M000441"></a>

        <div class="method-heading">
          <a href="Node.src/M000441.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000441.html');return false;">
          <span class="method-name">possible_paths_for</span><span class="method-args">(mappings)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Answer with an array of possible paths in order of significance for
template lookup of the given <tt>mappings</tt>.
</p>
<p>
@param [<a href="Node.html#M000416">map</a>] An array two Arrays of inner
and outer directories.
</p>
<p>
@return [Array] @see <a href="Node.html#M000438">update_view_mappings</a>
<a href="Node.html#M000439">update_layout_mappings</a> <a
href="Node.html#M000437">update_template_mappings</a> @author manveru
</p>
        </div>
      </div>

      <div id="method-M000417" class="method-detail">
        <a name="M000417"></a>

        <div class="method-heading">
          <a href="Node.src/M000417.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000417.html');return false;">
          <span class="method-name">provide</span><span class="method-args">(format, param = {}, &amp;block)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Specify which way contents are provided and processed.
</p>
<p>
Use this to set a templating engine, custom Content-Type, or pass a block
to take over the processing of the {<a href="Action.html">Action</a>} and
template yourself.
</p>
<p>
Provides set via this method will be inherited into subclasses.
</p>
<p>
The <tt>format</tt> is extracted from the PATH_INFO, it simply represents
the last extension name in the path.
</p>
<p>
The <a href="Node.html#M000417">provide</a> also has influence on the
chosen templates for the {<a href="Action.html">Action</a>}.
</p>
<p>
@example providing RSS with ERB templating
</p>
<pre>
  provide :rss, :engine =&gt; :ERB
</pre>
<p>
Given a request to `/list.rss` the template lookup first tries to find
`list.rss.erb`, if that fails it falls back to `list.erb`. If neither of
these are available it will try to use the return value of the method in
the {<a href="Action.html">Action</a>} as template.
</p>
<p>
A request to `/list.yaml` would match the format &#8216;yaml&#8216;
</p>
<p>
@example providing a yaml version of actions
</p>
<pre>
  class Articles
    include Innate::Node
    map '/article'

    provide(:yaml, :type =&gt; 'text/yaml'){|action, value| value.to_yaml }

    def list
      @articles = Article.list
    end
  end
</pre>
<p>
@example providing plain text inspect version
</p>
<pre>
  class Articles
    include Innate::Node
    map '/article'

    provide(:txt, :type =&gt; 'text/plain'){|action, value| value.inspect }

    def list
      @articles = Article.list
    end
  end
</pre>
<p>
@param [Proc] block
</p>
<pre>
  upon calling the action, [action, value] will be passed to it and its
  return value becomes the response body.
</pre>
<p>
@option param :engine [Symbol String]
</p>
<pre>
  Name of an engine for View::get
</pre>
<p>
@option param :type [String]
</p>
<pre>
  default Content-Type if none was set in Response
</pre>
<p>
@raise [ArgumentError] if neither a block nor an engine was given
</p>
<p>
@api external @see View::get <a href="Node.html#M000418">Node#provides</a>
@author manveru
</p>
<p>
@todo
</p>
<pre>
  The comment of this method may be too short for the effects it has on
  the rest of Innate, if you feel something is missing please let me
  know.
</pre>
        </div>
      </div>

      <div id="method-M000451" class="method-detail">
        <a name="M000451"></a>

        <div class="method-heading">
          <a href="Node.src/M000451.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000451.html');return false;">
          <span class="method-name">provide_set?</span><span class="method-args">()</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
This will return true if the only <a href="Node.html#M000418">provides</a>
set are by {Node::included}.
</p>
<p>
The reasoning behind this is to determine whether the user has touched the
<a href="Node.html#M000418">provides</a> at all, in which case we will not
override the <a href="Node.html#M000418">provides</a> in subclasses.
</p>
<p>
@return [true, false] (false)
</p>
<p>
@api internal @see {Node::included} @author manveru
</p>
        </div>
      </div>

      <div id="method-M000418" class="method-detail">
        <a name="M000418"></a>

        <div class="method-heading">
          <a href="Node.src/M000418.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000418.html');return false;">
          <span class="method-name">provides</span><span class="method-args">()</span>
          </a>
        </div>
      
        <div class="method-description">
        </div>
      </div>

      <div id="method-M000423" class="method-detail">
        <a name="M000423"></a>

        <div class="method-heading">
          <a href="Node.src/M000423.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000423.html');return false;">
          <span class="method-name">resolve</span><span class="method-args">(path)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Let&#8216;s get down to business, first check if we got any wishes
regarding the representation from the client, otherwise we will assume he
wants html.
</p>
<p>
@param [String] path
</p>
<p>
@return [nil, <a href="Action.html">Action</a>]
</p>
<p>
@api external @see Node::find_provide Node::update_method_arities
Node::find_action @author manveru
</p>
        </div>
      </div>

      <div id="method-M000444" class="method-detail">
        <a name="M000444"></a>

        <div class="method-heading">
          <a href="Node.src/M000444.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000444.html');return false;">
          <span class="method-name">root_mappings</span><span class="method-args">()</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
make sure this is an Array and a new instance so modification on the
wrapping array doesn&#8216;t affect the original option. [*arr].object_id
== arr.object_id if arr is an Array
</p>
<p>
@return [Array] list of root directories
</p>
<p>
@api external @author manveru
</p>
        </div>
      </div>

      <div id="method-M000433" class="method-detail">
        <a name="M000433"></a>

        <div class="method-heading">
          <a href="Node.src/M000433.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000433.html');return false;">
          <span class="method-name">to_layout</span><span class="method-args">(action_name, wish)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Find the best matching action_name for the <a
href="Node.html#M000434">layout</a>, if any.
</p>
<p>
This is mostly an abstract method that you might find handy if you want to
do vastly different <a href="Node.html#M000434">layout</a> lookup.
</p>
<p>
@param [String] action_name @param [String] wish
</p>
<p>
@return [nil, String] the absolute path to the template or nil
</p>
<p>
@api external @see {<a href="Node.html#M000436">Node#to_template</a>} {<a
href="Node.html#M000444">Node#root_mappings</a>} {<a
href="Node.html#M000448">Node#layout_mappings</a>} @author manveru
</p>
        </div>
      </div>

      <div id="method-M000436" class="method-detail">
        <a name="M000436"></a>

        <div class="method-heading">
          <a href="Node.src/M000436.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000436.html');return false;">
          <span class="method-name">to_template</span><span class="method-args">(path, wish)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Try to find a template at the given <tt>path</tt> for <tt>wish</tt>.
</p>
<p>
Since <a href="../Innate.html">Innate</a> supports multiple paths to
templates the <tt>path</tt> has to be an Array that may be nested one
level.
</p>
<p>
@example Usage to find available templates
</p>
<pre>
  # This assumes following files:
  # view/foo.erb
  # view/bar.erb
  # view/bar.rss.erb
  # view/bar.yaml.erb

  class FooBar
    Innate.node('/')
  end

  FooBar.to_template(['.', 'view', '/', 'foo'], 'html')
  # =&gt; &quot;./view/foo.erb&quot;
  FooBar.to_template(['.', 'view', '/', 'foo'], 'yaml')
  # =&gt; &quot;./view/foo.erb&quot;
  FooBar.to_template(['.', 'view', '/', 'foo'], 'rss')
  # =&gt; &quot;./view/foo.erb&quot;

  FooBar.to_template(['.', 'view', '/', 'bar'], 'html')
  # =&gt; &quot;./view/bar.erb&quot;
  FooBar.to_template(['.', 'view', '/', 'bar'], 'yaml')
  # =&gt; &quot;./view/bar.yaml.erb&quot;
  FooBar.to_template(['.', 'view', '/', 'bar'], 'rss')
  # =&gt; &quot;./view/bar.rss.erb&quot;
</pre>
<p>
@param [Array&lt;Array&lt;String&gt;&gt;, Array&lt;String&gt;] path
</p>
<pre>
  array containing strings and nested (1 level) arrays containing strings
</pre>
<p>
@param [String] wish
</p>
<p>
@return [nil, String] relative path to the first template found
</p>
<p>
@api external @see <a href="Node.html#M000429">Node#find_view</a> <a
href="Node.html#M000433">Node#to_layout</a> <a
href="Node.html#M000432">Node#find_aliased_view</a> @author manveru
</p>
        </div>
      </div>

      <div id="method-M000430" class="method-detail">
        <a name="M000430"></a>

        <div class="method-heading">
          <a href="Node.src/M000430.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000430.html');return false;">
          <span class="method-name">to_view</span><span class="method-args">(action_name, wish)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Try to find the best template for the given basename and wish.
</p>
<p>
This method is mostly here for symetry with {<a
href="Node.html#M000433">to_layout</a>} and to allow you overriding the
template lookup easily.
</p>
<p>
@param [to_s] action_name @param [to_s] wish
</p>
<p>
@return [String, nil] depending whether a template could be found
</p>
<p>
@api external @see {<a href="Node.html#M000429">Node#find_view</a>} {<a
href="Node.html#M000436">Node#to_template</a>} {<a
href="Node.html#M000444">Node#root_mappings</a>}
</p>
<pre>
     {Node#view_mappings} {Node#to_template}
</pre>
<p>
@author manveru
</p>
        </div>
      </div>

      <div id="method-M000420" class="method-detail">
        <a name="M000420"></a>

        <div class="method-heading">
          <a href="Node.src/M000420.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000420.html');return false;">
          <span class="method-name">try_resolve</span><span class="method-args">(path)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Let&#8216;s try to find some valid action for given <tt>path</tt>.
Otherwise we dispatch to {<a href="Node.html#M000422">action_missing</a>}.
</p>
<p>
@param [String] path from env[&#8216;PATH_INFO&#8217;]
</p>
<p>
@return [<a href="Response.html">Response</a>]
</p>
<p>
@api external @see <a href="Node.html#M000423">Node#resolve</a> <a
href="Node.html#M000421">Node#action_found</a> <a
href="Node.html#M000422">Node#action_missing</a> @author manveru
</p>
        </div>
      </div>

      <div id="method-M000439" class="method-detail">
        <a name="M000439"></a>

        <div class="method-heading">
          <a href="Node.src/M000439.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000439.html');return false;">
          <span class="method-name">update_layout_mappings</span><span class="method-args">()</span>
          </a>
        </div>
      
        <div class="method-description">
        </div>
      </div>

      <div id="method-M000440" class="method-detail">
        <a name="M000440"></a>

        <div class="method-heading">
          <a href="Node.src/M000440.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000440.html');return false;">
          <span class="method-name">update_mapping_shared</span><span class="method-args">(paths)</span>
          </a>
        </div>
      
        <div class="method-description">
        </div>
      </div>

      <div id="method-M000428" class="method-detail">
        <a name="M000428"></a>

        <div class="method-heading">
          <a href="Node.src/M000428.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000428.html');return false;">
          <span class="method-name">update_method_arities</span><span class="method-args">()</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Answer with a hash, keys are method names, values are method arities.
</p>
<p>
Note that this will be executed once for every request, once we have
settled things down a bit more we can switch to update based on Reloader
hooks and update once on startup. However, that may cause problems with
dynamically created methods, so let&#8216;s play it safe for now.
</p>
<p>
@example
</p>
<pre>
  Hi.update_method_arities
  # =&gt; {'index' =&gt; 0, 'foo' =&gt; -1, 'bar' =&gt; 2}
</pre>
<p>
@api internal @see <a href="Node.html#M000423">Node#resolve</a> @return
[Hash] <a href="Node.html#M000415">mapping</a> the name of the methods to
their arity
</p>
        </div>
      </div>

      <div id="method-M000437" class="method-detail">
        <a name="M000437"></a>

        <div class="method-heading">
          <a href="Node.src/M000437.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000437.html');return false;">
          <span class="method-name">update_template_mappings</span><span class="method-args">()</span>
          </a>
        </div>
      
        <div class="method-description">
        </div>
      </div>

      <div id="method-M000438" class="method-detail">
        <a name="M000438"></a>

        <div class="method-heading">
          <a href="Node.src/M000438.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000438.html');return false;">
          <span class="method-name">update_view_mappings</span><span class="method-args">()</span>
          </a>
        </div>
      
        <div class="method-description">
        </div>
      </div>

      <div id="method-M000446" class="method-detail">
        <a name="M000446"></a>

        <div class="method-heading">
          <a href="Node.src/M000446.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000446.html');return false;">
          <span class="method-name">view_mappings</span><span class="method-args">()</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Combine Innate.options.views with either the `ancestral_trait[:views]` or
the {<a href="Node.html#M000415">Node#mapping</a>} if the trait yields an
empty Array.
</p>
<p>
@return [Array&lt;String&gt;, Array&lt;Array&lt;String&gt;&gt;]
</p>
<p>
@api external @see {<a href="Node.html#M000445">Node#map_views</a>} @author
manveru
</p>
        </div>
      </div>


    </div>


  </div>


<div id="validator-badges">
  <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
</div>

</body>
</html>