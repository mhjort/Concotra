<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>Module: Diff::LCS</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <meta http-equiv="Content-Script-Type" content="text/javascript" />
  <link rel="stylesheet" href="../.././rdoc-style.css" type="text/css" media="screen" />
  <script type="text/javascript">
  // <![CDATA[

  function popupCode( url ) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;
    
    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  
  // Make codeblocks hidden by default
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }</style>" )
  
  // ]]>
  </script>

</head>
<body>



    <div id="classHeader">
        <table class="header-table">
        <tr class="top-aligned-row">
          <td><strong>Module</strong></td>
          <td class="class-name-in-header">Diff::LCS</td>
        </tr>
        <tr class="top-aligned-row">
            <td><strong>In:</strong></td>
            <td>
                <a href="../../files/lib/diff/lcs/callbacks_rb.html">
                lib/diff/lcs/callbacks.rb
                </a>
        <br />
                <a href="../../files/lib/diff/lcs_rb.html">
                lib/diff/lcs.rb
                </a>
        <br />
            </td>
        </tr>

        </table>
    </div>
  <!-- banner header -->

  <div id="bodyContent">



  <div id="contextContent">

    <div id="description">
      <h1><a href="LCS.html">Diff::LCS</a> 1.1.2</h1>
<p>
Computes &quot;intelligent&quot; differences between two sequenced
Enumerables. This is an implementation of the McIlroy-Hunt &quot;<a
href="LCS.html#M000333">diff</a>&quot; algorithm for Enumerable objects
that include Diffable.
</p>
<p>
Based on Mario I. Wolczko&#8216;s &lt;mario@wolczko.com&gt; Smalltalk
version (1.2, 1993) and Ned Konz&#8216;s &lt;perl@bike-nomad.com&gt; Perl
version (Algorithm::Diff).
</p>
<h2>Synopsis</h2>
<pre>
  require 'diff/lcs'

  seq1 = %w(a b c e h j l m n p)
  seq2 = %w(b c d e f j k l m r s t)

  lcs = Diff::LCS.LCS(seq1, seq2)
  diffs = Diff::LCS.diff(seq1, seq2)
  sdiff = Diff::LCS.sdiff(seq1, seq2)
  seq = Diff::LCS.traverse_sequences(seq1, seq2, callback_obj)
  bal = Diff::LCS.traverse_balanced(seq1, seq2, callback_obj)
  seq2 == Diff::LCS.patch(seq1, diffs)
  seq2 == Diff::LCS.patch!(seq1, diffs)
  seq1 == Diff::LCS.unpatch(seq2, diffs)
  seq1 == Diff::LCS.unpatch!(seq2, diffs)
  seq2 == Diff::LCS.patch(seq1, sdiff)
  seq2 == Diff::LCS.patch!(seq1, sdiff)
  seq1 == Diff::LCS.unpatch(seq2, sdiff)
  seq1 == Diff::LCS.unpatch!(seq2, sdiff)
</pre>
<p>
Alternatively, objects can be extended with <a
href="LCS.html">Diff::LCS</a>:
</p>
<pre>
  seq1.extend(Diff::LCS)
  lcs = seq1.lcs(seq2)
  diffs = seq1.diff(seq2)
  sdiff = seq1.sdiff(seq2)
  seq = seq1.traverse_sequences(seq2, callback_obj)
  bal = seq1.traverse_balanced(seq2, callback_obj)
  seq2 == seq1.patch(diffs)
  seq2 == seq1.patch!(diffs)
  seq1 == seq2.unpatch(diffs)
  seq1 == seq2.unpatch!(diffs)
  seq2 == seq1.patch(sdiff)
  seq2 == seq1.patch!(sdiff)
  seq1 == seq2.unpatch(sdiff)
  seq1 == seq2.unpatch!(sdiff)
</pre>
<p>
Default extensions are provided for <a href="../Array.html">Array</a> and
<a href="../String.html">String</a> objects through the use of
&#8216;diff/lcs/array&#8217; and &#8216;diff/lcs/string&#8217;.
</p>
<h2>Introduction (by Mark-Jason Dominus)</h2>
<p>
<em>The following text is from the Perl documentation. The only changes
have been to make the text appear better in Rdoc</em>.
</p>
<p>
I once read an article written by the authors of <tt><a
href="LCS.html#M000333">diff</a></tt>; they said that they hard worked very
hard on the algorithm until they found the right one.
</p>
<p>
I think what they ended up using (and I hope someone will correct me,
because I am not very confident about this) was the `longest common
subsequence&#8217; method. In the <a href="LCS.html#M000341">LCS</a>
problem, you have two sequences of items:
</p>
<pre>
   a b c d f g h j q z
   a b c d e f g i j k r x y z
</pre>
<p>
and you want to find the longest sequence of items that is present in both
original sequences in the same order. That is, you want to find a new
sequence <b>S</b> which can be obtained from the first sequence by deleting
some items, and from the second sequence by deleting other items. You also
want <b>S</b> to be as long as possible. In this case <b>S</b> is:
</p>
<pre>
   a b c d f g j z
</pre>
<p>
From there it&#8216;s only a small step to get <a
href="LCS.html#M000333">diff</a>-like output:
</p>
<pre>
   e   h i   k   q r x y
   +   - +   +   - + + +
</pre>
<p>
This module solves the <a href="LCS.html#M000341">LCS</a> problem. It also
includes a canned function to generate <tt><a
href="LCS.html#M000333">diff</a></tt>-like output.
</p>
<p>
It might seem from the example above that the <a
href="LCS.html#M000341">LCS</a> of two sequences is always pretty obvious,
but that&#8216;s not always the case, especially when the two sequences
have many repeated elements. For example, consider
</p>
<pre>
   a x b y c z p d q
   a b c a x b y c z
</pre>
<p>
A naive approach might start by matching up the <tt>a</tt> and <tt>b</tt>
that appear at the beginning of each sequence, like this:
</p>
<pre>
   a x b y c         z p d q
   a   b   c a b y c z
</pre>
<p>
This finds the common subsequence +a b c z+. But actually, the <a
href="LCS.html#M000341">LCS</a> is +a x b y c z+:
</p>
<pre>
         a x b y c z p d q
   a b c a x b y c z
</pre>
<h2>Author</h2>
<p>
This version is by Austin Ziegler &lt;<a
href="LCS.html#M000333">diff</a>-<a
href="LCS.html#M000332">lcs</a>@halostatue.ca&gt;.
</p>
<p>
It is based on the Perl Algorithm::Diff by Ned Konz
&lt;perl@bike-nomad.com&gt;, copyright &amp;copy; 2000 - 2002 and the
Smalltalk <a href="LCS.html#M000333">diff</a> version by Mario I. Wolczko
&lt;mario@wolczko.com&gt;, copyright &amp;copy;
</p>
<ol>
<li>Documentation includes work by Mark-Jason Dominus.

</li>
</ol>
<h2>Licence</h2>
<p>
Copyright &amp;copy; 2004 Austin Ziegler This program is free software; you
can redistribute it and/or modify it under the same terms as Ruby, or
alternatively under the Perl Artistic licence.
</p>
<h2>Credits</h2>
<p>
Much of the documentation is taken directly from the Perl Algorithm::Diff
implementation and was written originally by Mark-Jason Dominus
&lt;mjd-perl-<a href="LCS.html#M000333">diff</a>@plover.com&gt; and later
by Ned Konz. The basic Ruby implementation was re-ported from the Smalltalk
implementation, available at <a
href="ftp://st.cs.uiuc.edu/pub/Smalltalk/MANCHESTER/manchester/4.0/diff.st">st.cs.uiuc.edu/pub/Smalltalk/MANCHESTER/manchester/4.0/diff.st</a>
</p>
<p>
<a href="LCS.html#M000334">sdiff</a> and <a
href="LCS.html#M000336">traverse_balanced</a> were written for the Perl
version by Mike Schilli &lt;m@perlmeister.com&gt;.
</p>
<p>
&quot;The algorithm is described in <em>A Fast Algorithm for Computing
Longest Common Subsequences</em>, CACM, vol.20, no.5, pp.350-353, May 1977,
with a few minor improvements to improve the speed.&quot;
</p>

    </div>


   </div>

    <div id="method-list">
      <h3 class="section-bar">Methods</h3>

      <div class="name-list">
      <a href="#M000341">LCS</a>&nbsp;&nbsp;
      <a href="#M000353">__diff_direction</a>&nbsp;&nbsp;
      <a href="#M000351">__inverse_vector</a>&nbsp;&nbsp;
      <a href="#M000349">__lcs</a>&nbsp;&nbsp;
      <a href="#M000354">__normalize_patchset</a>&nbsp;&nbsp;
      <a href="#M000352">__position_hash</a>&nbsp;&nbsp;
      <a href="#M000350">__replace_next_larger</a>&nbsp;&nbsp;
      <a href="#M000333">diff</a>&nbsp;&nbsp;
      <a href="#M000342">diff</a>&nbsp;&nbsp;
      <a href="#M000332">lcs</a>&nbsp;&nbsp;
      <a href="#M000346">patch</a>&nbsp;&nbsp;
      <a href="#M000337">patch</a>&nbsp;&nbsp;
      <a href="#M000348">patch!</a>&nbsp;&nbsp;
      <a href="#M000339">patch!</a>&nbsp;&nbsp;
      <a href="#M000343">sdiff</a>&nbsp;&nbsp;
      <a href="#M000334">sdiff</a>&nbsp;&nbsp;
      <a href="#M000345">traverse_balanced</a>&nbsp;&nbsp;
      <a href="#M000336">traverse_balanced</a>&nbsp;&nbsp;
      <a href="#M000344">traverse_sequences</a>&nbsp;&nbsp;
      <a href="#M000335">traverse_sequences</a>&nbsp;&nbsp;
      <a href="#M000338">unpatch</a>&nbsp;&nbsp;
      <a href="#M000347">unpatch!</a>&nbsp;&nbsp;
      <a href="#M000340">unpatch!</a>&nbsp;&nbsp;
      </div>
    </div>

  </div>


    <!-- if includes -->

    <div id="section">

    <div id="class-list">
      <h3 class="section-bar">Classes and Modules</h3>

      Module <a href="LCS/ChangeTypeTests.html" class="link">Diff::LCS::ChangeTypeTests</a><br />
Module <a href="LCS/Ldiff.html" class="link">Diff::LCS::Ldiff</a><br />
Class <a href="LCS/Block.html" class="link">Diff::LCS::Block</a><br />
Class <a href="LCS/Change.html" class="link">Diff::LCS::Change</a><br />
Class <a href="LCS/ContextChange.html" class="link">Diff::LCS::ContextChange</a><br />
Class <a href="LCS/ContextDiffCallbacks.html" class="link">Diff::LCS::ContextDiffCallbacks</a><br />
Class <a href="LCS/DefaultCallbacks.html" class="link">Diff::LCS::DefaultCallbacks</a><br />
Class <a href="LCS/DiffCallbacks.html" class="link">Diff::LCS::DiffCallbacks</a><br />
Class <a href="LCS/Hunk.html" class="link">Diff::LCS::Hunk</a><br />
Class <a href="LCS/SDiffCallbacks.html" class="link">Diff::LCS::SDiffCallbacks</a><br />

    </div>

    <div id="constants-list">
      <h3 class="section-bar">Constants</h3>

      <div class="name-list">
        <table summary="Constants">
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">SequenceCallbacks</td>
          <td>=</td>
          <td class="context-item-value">DefaultCallbacks</td>
          <td width="3em">&nbsp;</td>
          <td class="context-item-desc">
An alias for <a href="LCS/DefaultCallbacks.html">DefaultCallbacks</a> that
is used in <a href="LCS.html#M000335">Diff::LCS#traverse_sequences</a>.

<pre>
    Diff::LCS.LCS(seq1, seq2, Diff::LCS::SequenceCallbacks)
</pre>
</td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">BalancedCallbacks</td>
          <td>=</td>
          <td class="context-item-value">DefaultCallbacks</td>
          <td width="3em">&nbsp;</td>
          <td class="context-item-desc">
An alias for <a href="LCS/DefaultCallbacks.html">DefaultCallbacks</a> that
is used in <a href="LCS.html#M000336">Diff::LCS#traverse_balanced</a>.

<pre>
    Diff::LCS.LCS(seq1, seq2, Diff::LCS::BalancedCallbacks)
</pre>
</td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">VERSION</td>
          <td>=</td>
          <td class="context-item-value">'1.1.2'</td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">PATCH_MAP</td>
          <td>=</td>
          <td class="context-item-value">{ #:nodoc:       :patch =&gt; { '+' =&gt; '+', '-' =&gt; '-', '!' =&gt; '!', '=' =&gt; '=' },       :unpatch =&gt; { '+' =&gt; '-', '-' =&gt; '+', '!' =&gt; '!', '=' =&gt; '=' }</td>
        </tr>
        </table>
      </div>
    </div>



      


    <!-- if method_list -->
    <div id="methods">
      <h3 class="section-bar">Public Class methods</h3>

      <div id="method-M000341" class="method-detail">
        <a name="M000341"></a>

        <div class="method-heading">
          <a href="LCS.src/M000341.html" target="Code" class="method-signature"
            onclick="popupCode('LCS.src/M000341.html');return false;">
          <span class="method-name">LCS</span><span class="method-args">(seq1, seq2) {|seq1[ii])| ...}</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Given two sequenced Enumerables, <a href="LCS.html#M000341">LCS</a> returns
an <a href="../Array.html">Array</a> containing their longest common
subsequences.
</p>
<pre>
  lcs = Diff::LCS.LCS(seq1, seq2)
</pre>
<p>
This array whose contents is such that:
</p>
<pre>
  lcs.each_with_index do |ee, ii|
    assert(ee.nil? || (seq1[ii] == seq2[ee]))
  end
</pre>
<p>
If a block is provided, the matching subsequences will be yielded from
+seq1+ in turn and may be modified before they are placed into the returned
<a href="../Array.html">Array</a> of subsequences.
</p>
        </div>
      </div>

      <div id="method-M000353" class="method-detail">
        <a name="M000353"></a>

        <div class="method-heading">
          <a href="LCS.src/M000353.html" target="Code" class="method-signature"
            onclick="popupCode('LCS.src/M000353.html');return false;">
          <span class="method-name">__diff_direction</span><span class="method-args">(src, patchset, limit = nil)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Examine the patchset and the source to see in which direction the <a
href="LCS.html#M000337">patch</a> should be applied.
</p>
<p>
WARNING: By default, this examines the whole <a
href="LCS.html#M000337">patch</a>, so this could take some time. This also
works better with <a
href="LCS/ContextChange.html">Diff::LCS::ContextChange</a> or <a
href="LCS/Change.html">Diff::LCS::Change</a> as its source, as an array
will cause the creation of one of the above.
</p>
        </div>
      </div>

      <div id="method-M000351" class="method-detail">
        <a name="M000351"></a>

        <div class="method-heading">
          <a href="LCS.src/M000351.html" target="Code" class="method-signature"
            onclick="popupCode('LCS.src/M000351.html');return false;">
          <span class="method-name">__inverse_vector</span><span class="method-args">(a, vector)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
If <tt>vector</tt> maps the matching elements of another collection onto
this Enumerable, compute the inverse <tt>vector</tt> that maps this
Enumerable onto the collection. (Currently unused.)
</p>
        </div>
      </div>

      <div id="method-M000349" class="method-detail">
        <a name="M000349"></a>

        <div class="method-heading">
          <a href="LCS.src/M000349.html" target="Code" class="method-signature"
            onclick="popupCode('LCS.src/M000349.html');return false;">
          <span class="method-name">__lcs</span><span class="method-args">(a, b)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
private Compute the longest common subsequence between the sequenced
Enumerables <tt>a</tt> and <tt>b</tt>. The result is an array whose
contents is such that
</p>
<pre>
    result = Diff::LCS.__lcs(a, b)
    result.each_with_index do |e, ii|
      assert_equal(a[ii], b[e]) unless e.nil?
    end
</pre>
        </div>
      </div>

      <div id="method-M000354" class="method-detail">
        <a name="M000354"></a>

        <div class="method-heading">
          <a href="LCS.src/M000354.html" target="Code" class="method-signature"
            onclick="popupCode('LCS.src/M000354.html');return false;">
          <span class="method-name">__normalize_patchset</span><span class="method-args">(patchset)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Normalize the patchset. A patchset is always a sequence of changes, but how
those changes are represented may vary, depending on how they were
generated. In all cases we support, we also support the array
representation of the changes. The formats are:
</p>
<pre>
  [ # patchset &lt;- Diff::LCS.diff(a, b)
    [ # one or more hunks
      Diff::LCS::Change # one or more changes
    ] ]

  [ # patchset, equivalent to the above
    [ # one or more hunks
      [ action, line, value ] # one or more changes
    ] ]

  [ # patchset &lt;- Diff::LCS.diff(a, b, Diff::LCS::ContextDiffCallbacks)
    #       OR &lt;- Diff::LCS.sdiff(a, b, Diff::LCS::ContextDiffCallbacks)
    [ # one or more hunks
      Diff::LCS::ContextChange # one or more changes
    ] ]

  [ # patchset, equivalent to the above
    [ # one or more hunks
      [ action, [ old line, old value ], [ new line, new value ] ]
        # one or more changes
    ] ]

  [ # patchset &lt;- Diff::LCS.sdiff(a, b)
    #       OR &lt;- Diff::LCS.diff(a, b, Diff::LCS::SDiffCallbacks)
    Diff::LCS::ContextChange # one or more changes
  ]

  [ # patchset, equivalent to the above
    [ action, [ old line, old value ], [ new line, new value ] ]
      # one or more changes
  ]
</pre>
<p>
The result of this will be either of the following.
</p>
<pre>
  [ # patchset
    Diff::LCS::ContextChange # one or more changes
  ]

  [ # patchset
    Diff::LCS::Change # one or more changes
  ]
</pre>
<p>
If either of the above is provided, it will be returned as such.
</p>
        </div>
      </div>

      <div id="method-M000352" class="method-detail">
        <a name="M000352"></a>

        <div class="method-heading">
          <a href="LCS.src/M000352.html" target="Code" class="method-signature"
            onclick="popupCode('LCS.src/M000352.html');return false;">
          <span class="method-name">__position_hash</span><span class="method-args">(enum, interval = 0 .. -1)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Returns a hash mapping each element of an Enumerable to the set of
positions it occupies in the Enumerable, optionally restricted to the
elements specified in the range of indexes specified by <tt>interval</tt>.
</p>
        </div>
      </div>

      <div id="method-M000350" class="method-detail">
        <a name="M000350"></a>

        <div class="method-heading">
          <a href="LCS.src/M000350.html" target="Code" class="method-signature"
            onclick="popupCode('LCS.src/M000350.html');return false;">
          <span class="method-name">__replace_next_larger</span><span class="method-args">(enum, value, last_index = nil)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Find the place at which <tt>value</tt> would normally be inserted into the
Enumerable. If that place is already occupied by <tt>value</tt>, do nothing
and return <tt>nil</tt>. If the place does not exist (i.e., it is off the
end of the Enumerable), add it to the end. Otherwise, replace the element
at that point with <tt>value</tt>. It is assumed that the
Enumerable&#8216;s values are numeric.
</p>
<p>
This operation preserves the sort order.
</p>
        </div>
      </div>

      <div id="method-M000342" class="method-detail">
        <a name="M000342"></a>

        <div class="method-heading">
          <a href="LCS.src/M000342.html" target="Code" class="method-signature"
            onclick="popupCode('LCS.src/M000342.html');return false;">
          <span class="method-name">diff</span><span class="method-args">(seq1, seq2, callbacks = nil) {|block| ...}</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
<a href="LCS.html#M000333">Diff::LCS.diff</a> computes the smallest set of
additions and deletions necessary to turn the first sequence into the
second, and returns a description of these changes.
</p>
<p>
See <a href="LCS/DiffCallbacks.html">Diff::LCS::DiffCallbacks</a> for the
default behaviour. An alternate behaviour may be implemented with <a
href="LCS/ContextDiffCallbacks.html">Diff::LCS::ContextDiffCallbacks</a>.
If a Class argument is provided for <tt>callbacks</tt>, <a
href="LCS.html#M000333">diff</a> will attempt to initialise it. If the
<tt>callbacks</tt> object (possibly initialised) responds to finish, it
will be called.
</p>
        </div>
      </div>

      <div id="method-M000346" class="method-detail">
        <a name="M000346"></a>

        <div class="method-heading">
          <a href="LCS.src/M000346.html" target="Code" class="method-signature"
            onclick="popupCode('LCS.src/M000346.html');return false;">
          <span class="method-name">patch</span><span class="method-args">(src, patchset, direction = nil)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Given a patchset, convert the current version to the new version. If
<tt>direction</tt> is not specified (must be <tt>:<a
href="LCS.html#M000337">patch</a></tt> or <tt>:<a
href="LCS.html#M000338">unpatch</a></tt>), then discovery of the direction
of the <a href="LCS.html#M000337">patch</a> will be attempted.
</p>
        </div>
      </div>

      <div id="method-M000348" class="method-detail">
        <a name="M000348"></a>

        <div class="method-heading">
          <a href="LCS.src/M000348.html" target="Code" class="method-signature"
            onclick="popupCode('LCS.src/M000348.html');return false;">
          <span class="method-name">patch!</span><span class="method-args">(src, patchset)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Given a set of patchset, convert the current version to the next version.
Does no auto-discovery.
</p>
        </div>
      </div>

      <div id="method-M000343" class="method-detail">
        <a name="M000343"></a>

        <div class="method-heading">
          <a href="LCS.src/M000343.html" target="Code" class="method-signature"
            onclick="popupCode('LCS.src/M000343.html');return false;">
          <span class="method-name">sdiff</span><span class="method-args">(seq1, seq2, callbacks = nil) {|block| ...}</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
<a href="LCS.html#M000334">Diff::LCS.sdiff</a> computes all necessary
components to show two sequences and their minimized differences side by
side, just like the Unix utility <em><a
href="LCS.html#M000334">sdiff</a></em> does:
</p>
<pre>
    old        &lt;     -
    same             same
    before     |     after
    -          &gt;     new
</pre>
<p>
See <a href="LCS/SDiffCallbacks.html">Diff::LCS::SDiffCallbacks</a> for the
default behaviour. An alternate behaviour may be implemented with <a
href="LCS/ContextDiffCallbacks.html">Diff::LCS::ContextDiffCallbacks</a>.
If a Class argument is provided for <tt>callbacks</tt>, <a
href="LCS.html#M000333">diff</a> will attempt to initialise it. If the
<tt>callbacks</tt> object (possibly initialised) responds to finish, it
will be called.
</p>
        </div>
      </div>

      <div id="method-M000345" class="method-detail">
        <a name="M000345"></a>

        <div class="method-heading">
          <a href="LCS.src/M000345.html" target="Code" class="method-signature"
            onclick="popupCode('LCS.src/M000345.html');return false;">
          <span class="method-name">traverse_balanced</span><span class="method-args">(seq1, seq2, callbacks = Diff::LCS::BalancedCallbacks) {|event if block_given?| ...}</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
<a href="LCS.html#M000336">traverse_balanced</a> is an alternative to <a
href="LCS.html#M000335">traverse_sequences</a>. It uses a different
algorithm to iterate through the entries in the computed longest common
subsequence. Instead of viewing the changes as insertions or deletions from
one of the sequences, <a href="LCS.html#M000336">traverse_balanced</a> will
report <em>changes</em> between the sequences. To represent a
</p>
<p>
The arguments to <a href="LCS.html#M000336">traverse_balanced</a> are the
two sequences to traverse and a callback object, like this:
</p>
<pre>
  traverse_balanced(seq1, seq2, Diff::LCS::ContextDiffCallbacks.new)
</pre>
<p>
<a href="LCS.html#M000334">sdiff</a> is implemented with <a
href="LCS.html#M000336">traverse_balanced</a>.
</p>
<h2>Callback Methods</h2>
<p>
Optional callback methods are <em>emphasized</em>.
</p>
<table>
<tr><td valign="top">callbacks#match:</td><td>Called when <tt>a</tt> and <tt>b</tt> are pointing to common elements in
<tt>A</tt> and <tt>B</tt>.

</td></tr>
<tr><td valign="top">callbacks#discard_a:</td><td>Called when <tt>a</tt> is pointing to an element not in <tt>B</tt>.

</td></tr>
<tr><td valign="top">callbacks#discard_b:</td><td>Called when <tt>b</tt> is pointing to an element not in <tt>A</tt>.

</td></tr>
<tr><td valign="top"><em>callbacks#change</em>:</td><td>Called when <tt>a</tt> and <tt>b</tt> are pointing to the same relative
position, but <tt>A[a]</tt> and <tt>B[b]</tt> are not the same; a
<em>change</em> has occurred.

</td></tr>
</table>
<p>
<a href="LCS.html#M000336">traverse_balanced</a> might be a bit slower than
<a href="LCS.html#M000335">traverse_sequences</a>, noticable only while
processing huge amounts of data.
</p>
<p>
The <tt><a href="LCS.html#M000334">sdiff</a></tt> function of this module
is implemented as call to <a href="LCS.html#M000336">traverse_balanced</a>.
</p>
<h2>Algorithm</h2>
<pre>
      a---+
          v
      A = a b c e h j l m n p
      B = b c d e f j k l m r s t
          ^
      b---+
</pre>
<h3>Matches</h3>
<p>
If there are two arrows (<tt>a</tt> and <tt>b</tt>) pointing to elements of
sequences <tt>A</tt> and <tt>B</tt>, the arrows will initially point to the
first elements of their respective sequences. <a
href="LCS.html#M000335">traverse_sequences</a> will advance the arrows
through the sequences one element at a time, calling a method on the
user-specified callback object before each advance. It will advance the
arrows in such a way that if there are elements <tt>A[ii]</tt> and
<tt>B[jj]</tt> which are both equal and part of the longest common
subsequence, there will be some moment during the execution of <a
href="LCS.html#M000335">traverse_sequences</a> when arrow <tt>a</tt> is
pointing to <tt>A[ii]</tt> and arrow <tt>b</tt> is pointing to
<tt>B[jj]</tt>. When this happens, <a
href="LCS.html#M000335">traverse_sequences</a> will call
<tt>callbacks#match</tt> and then it will advance both arrows.
</p>
<h3>Discards</h3>
<p>
Otherwise, one of the arrows is pointing to an element of its sequence that
is not part of the longest common subsequence. <a
href="LCS.html#M000335">traverse_sequences</a> will advance that arrow and
will call <tt>callbacks#discard_a</tt> or <tt>callbacks#discard_b</tt>,
depending on which arrow it advanced.
</p>
<h3>Changes</h3>
<p>
If both <tt>a</tt> and <tt>b</tt> point to elements that are not part of
the longest common subsequence, then <a
href="LCS.html#M000335">traverse_sequences</a> will try to call
<tt>callbacks#change</tt> and advance both arrows. If
<tt>callbacks#change</tt> is not implemented, then
<tt>callbacks#discard_a</tt> and <tt>callbacks#discard_b</tt> will be
called in turn.
</p>
<p>
The methods for <tt>callbacks#match</tt>, <tt>callbacks#discard_a</tt>,
<tt>callbacks#discard_b</tt>, and <tt>callbacks#change</tt> are invoked
with an event comprising the action (&quot;=&quot;, &quot;+&quot;,
&quot;-&quot;, or &quot;!&quot;, respectively), the indicies <tt>ii</tt>
and <tt>jj</tt>, and the elements <tt>A[ii]</tt> and <tt>B[jj]</tt>. Return
values are discarded by <a href="LCS.html#M000336">traverse_balanced</a>.
</p>
<h3>Context</h3>
<p>
Note that <tt>ii</tt> and <tt>jj</tt> may not be the same index position,
even if <tt>a</tt> and <tt>b</tt> are considered to be pointing to matching
or changed elements.
</p>
        </div>
      </div>

      <div id="method-M000344" class="method-detail">
        <a name="M000344"></a>

        <div class="method-heading">
          <a href="LCS.src/M000344.html" target="Code" class="method-signature"
            onclick="popupCode('LCS.src/M000344.html');return false;">
          <span class="method-name">traverse_sequences</span><span class="method-args">(seq1, seq2, callbacks = Diff::LCS::SequenceCallbacks) {|event if block_given?| ...}</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
<a href="LCS.html#M000335">Diff::LCS.traverse_sequences</a> is the most
general facility provided by this module; <tt><a
href="LCS.html#M000333">diff</a></tt> and <tt><a
href="LCS.html#M000341">LCS</a></tt> are implemented as calls to it.
</p>
<p>
The arguments to <a href="LCS.html#M000335">traverse_sequences</a> are the
two sequences to traverse, and a callback object, like this:
</p>
<pre>
  traverse_sequences(seq1, seq2, Diff::LCS::ContextDiffCallbacks.new)
</pre>
<p>
<a href="LCS.html#M000333">diff</a> is implemented with <a
href="LCS.html#M000335">traverse_sequences</a>.
</p>
<h2>Callback Methods</h2>
<p>
Optional callback methods are <em>emphasized</em>.
</p>
<table>
<tr><td valign="top">callbacks#match:</td><td>Called when <tt>a</tt> and <tt>b</tt> are pointing to common elements in
<tt>A</tt> and <tt>B</tt>.

</td></tr>
<tr><td valign="top">callbacks#discard_a:</td><td>Called when <tt>a</tt> is pointing to an element not in <tt>B</tt>.

</td></tr>
<tr><td valign="top">callbacks#discard_b:</td><td>Called when <tt>b</tt> is pointing to an element not in <tt>A</tt>.

</td></tr>
<tr><td valign="top"><em>callbacks#finished_a</em>:</td><td>Called when <tt>a</tt> has reached the end of sequence <tt>A</tt>.

</td></tr>
<tr><td valign="top"><em>callbacks#finished_b</em>:</td><td>Called when <tt>b</tt> has reached the end of sequence <tt>B</tt>.

</td></tr>
</table>
<h2>Algorithm</h2>
<pre>
      a---+
          v
      A = a b c e h j l m n p
      B = b c d e f j k l m r s t
          ^
      b---+
</pre>
<p>
If there are two arrows (<tt>a</tt> and <tt>b</tt>) pointing to elements of
sequences <tt>A</tt> and <tt>B</tt>, the arrows will initially point to the
first elements of their respective sequences. <a
href="LCS.html#M000335">traverse_sequences</a> will advance the arrows
through the sequences one element at a time, calling a method on the
user-specified callback object before each advance. It will advance the
arrows in such a way that if there are elements <tt>A[ii]</tt> and
<tt>B[jj]</tt> which are both equal and part of the longest common
subsequence, there will be some moment during the execution of <a
href="LCS.html#M000335">traverse_sequences</a> when arrow <tt>a</tt> is
pointing to <tt>A[ii]</tt> and arrow <tt>b</tt> is pointing to
<tt>B[jj]</tt>. When this happens, <a
href="LCS.html#M000335">traverse_sequences</a> will call
<tt>callbacks#match</tt> and then it will advance both arrows.
</p>
<p>
Otherwise, one of the arrows is pointing to an element of its sequence that
is not part of the longest common subsequence. <a
href="LCS.html#M000335">traverse_sequences</a> will advance that arrow and
will call <tt>callbacks#discard_a</tt> or <tt>callbacks#discard_b</tt>,
depending on which arrow it advanced. If both arrows point to elements that
are not part of the longest common subsequence, then <a
href="LCS.html#M000335">traverse_sequences</a> will advance one of them and
call the appropriate callback, but it is not specified which it will call.
</p>
<p>
The methods for <tt>callbacks#match</tt>, <tt>callbacks#discard_a</tt>, and
<tt>callbacks#discard_b</tt> are invoked with an event comprising the
action (&quot;=&quot;, &quot;+&quot;, or &quot;-&quot;, respectively), the
indicies <tt>ii</tt> and <tt>jj</tt>, and the elements <tt>A[ii]</tt> and
<tt>B[jj]</tt>. Return values are discarded by <a
href="LCS.html#M000335">traverse_sequences</a>.
</p>
<h3>End of Sequences</h3>
<p>
If arrow <tt>a</tt> reaches the end of its sequence before arrow <tt>b</tt>
does, traverse_sequence try to call <tt>callbacks#finished_a</tt> with the
last index and element of <tt>A</tt> (<tt>A[-1]</tt>) and the current index
and element of <tt>B</tt> (<tt>B[jj]</tt>). If
<tt>callbacks#finished_a</tt> does not exist, then
<tt>callbacks#discard_b</tt> will be called on each element of <tt>B</tt>
until the end of the sequence is reached (the call will be done with
<tt>A[-1]</tt> and <tt>B[jj]</tt> for each element).
</p>
<p>
If <tt>b</tt> reaches the end of <tt>B</tt> before <tt>a</tt> reaches the
end of <tt>A</tt>, <tt>callbacks#finished_b</tt> will be called with the
current index and element of <tt>A</tt> (<tt>A[ii]</tt>) and the last index
and element of <tt>B</tt> (<tt>A[-1]</tt>). Again, if
<tt>callbacks#finished_b</tt> does not exist on the callback object, then
<tt>callbacks#discard_a</tt> will be called on each element of <tt>A</tt>
until the end of the sequence is reached (<tt>A[ii]</tt> and
<tt>B[-1]</tt>).
</p>
<p>
There is a chance that one additional <tt>callbacks#discard_a</tt> or
<tt>callbacks#discard_b</tt> will be called after the end of the sequence
is reached, if <tt>a</tt> has not yet reached the end of <tt>A</tt> or
<tt>b</tt> has not yet reached the end of <tt>B</tt>.
</p>
        </div>
      </div>

      <div id="method-M000347" class="method-detail">
        <a name="M000347"></a>

        <div class="method-heading">
          <a href="LCS.src/M000347.html" target="Code" class="method-signature"
            onclick="popupCode('LCS.src/M000347.html');return false;">
          <span class="method-name">unpatch!</span><span class="method-args">(src, patchset)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Given a set of patchset, convert the current version to the prior version.
Does no auto-discovery.
</p>
        </div>
      </div>

      <h3 class="section-bar">Public Instance methods</h3>

      <div id="method-M000333" class="method-detail">
        <a name="M000333"></a>

        <div class="method-heading">
          <a href="LCS.src/M000333.html" target="Code" class="method-signature"
            onclick="popupCode('LCS.src/M000333.html');return false;">
          <span class="method-name">diff</span><span class="method-args">(other, callbacks = nil, &amp;block)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Returns the difference set between <tt>self</tt> and <tt>other</tt>. See <a
href="LCS.html#M000333">Diff::LCS#diff</a>.
</p>
        </div>
      </div>

      <div id="method-M000332" class="method-detail">
        <a name="M000332"></a>

        <div class="method-heading">
          <a href="LCS.src/M000332.html" target="Code" class="method-signature"
            onclick="popupCode('LCS.src/M000332.html');return false;">
          <span class="method-name">lcs</span><span class="method-args">(other, &amp;block)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Returns an <a href="../Array.html">Array</a> containing the longest common
subsequence(s) between <tt>self</tt> and <tt>other</tt>. See <a
href="LCS.html#M000341">Diff::LCS#LCS</a>.
</p>
<pre>
  lcs = seq1.lcs(seq2)
</pre>
        </div>
      </div>

      <div id="method-M000337" class="method-detail">
        <a name="M000337"></a>

        <div class="method-heading">
          <a href="LCS.src/M000337.html" target="Code" class="method-signature"
            onclick="popupCode('LCS.src/M000337.html');return false;">
          <span class="method-name">patch</span><span class="method-args">(patchset)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Attempts to <a href="LCS.html#M000337">patch</a> a copy of <tt>self</tt>
with the provided <tt>patchset</tt>. See <a
href="LCS.html#M000337">Diff::LCS#patch</a>.
</p>
        </div>
      </div>

      <div id="method-M000339" class="method-detail">
        <a name="M000339"></a>

        <div class="method-heading">
          <a href="LCS.src/M000339.html" target="Code" class="method-signature"
            onclick="popupCode('LCS.src/M000339.html');return false;">
          <span class="method-name">patch!</span><span class="method-args">(patchset)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Attempts to <a href="LCS.html#M000337">patch</a> <tt>self</tt> with the
provided <tt>patchset</tt>. See <a
href="LCS.html#M000337">Diff::LCS#patch</a>!. Does no autodiscovery.
</p>
        </div>
      </div>

      <div id="method-M000334" class="method-detail">
        <a name="M000334"></a>

        <div class="method-heading">
          <a href="LCS.src/M000334.html" target="Code" class="method-signature"
            onclick="popupCode('LCS.src/M000334.html');return false;">
          <span class="method-name">sdiff</span><span class="method-args">(other, callbacks = nil, &amp;block)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Returns the balanced (&quot;side-by-side&quot;) difference set between
<tt>self</tt> and <tt>other</tt>. See <a
href="LCS.html#M000334">Diff::LCS#sdiff</a>.
</p>
        </div>
      </div>

      <div id="method-M000336" class="method-detail">
        <a name="M000336"></a>

        <div class="method-heading">
          <a href="LCS.src/M000336.html" target="Code" class="method-signature"
            onclick="popupCode('LCS.src/M000336.html');return false;">
          <span class="method-name">traverse_balanced</span><span class="method-args">(other, callbacks = nil, &amp;block)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Traverses the discovered longest common subsequences between <tt>self</tt>
and <tt>other</tt> using the alternate, balanced algorithm. See <a
href="LCS.html#M000336">Diff::LCS#traverse_balanced</a>.
</p>
        </div>
      </div>

      <div id="method-M000335" class="method-detail">
        <a name="M000335"></a>

        <div class="method-heading">
          <a href="LCS.src/M000335.html" target="Code" class="method-signature"
            onclick="popupCode('LCS.src/M000335.html');return false;">
          <span class="method-name">traverse_sequences</span><span class="method-args">(other, callbacks = nil, &amp;block)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Traverses the discovered longest common subsequences between <tt>self</tt>
and <tt>other</tt>. See <a
href="LCS.html#M000335">Diff::LCS#traverse_sequences</a>.
</p>
        </div>
      </div>

      <div id="method-M000338" class="method-detail">
        <a name="M000338"></a>

        <div class="method-heading">
          <a href="LCS.src/M000338.html" target="Code" class="method-signature"
            onclick="popupCode('LCS.src/M000338.html');return false;">
          <span class="method-name">unpatch</span><span class="method-args">(patchset)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Attempts to <a href="LCS.html#M000338">unpatch</a> a copy of <tt>self</tt>
with the provided <tt>patchset</tt>. See <a
href="LCS.html#M000337">Diff::LCS#patch</a>.
</p>
        </div>
      </div>

      <div id="method-M000340" class="method-detail">
        <a name="M000340"></a>

        <div class="method-heading">
          <a href="LCS.src/M000340.html" target="Code" class="method-signature"
            onclick="popupCode('LCS.src/M000340.html');return false;">
          <span class="method-name">unpatch!</span><span class="method-args">(patchset)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Attempts to <a href="LCS.html#M000338">unpatch</a> <tt>self</tt> with the
provided <tt>patchset</tt>. See <a
href="LCS.html#M000338">Diff::LCS#unpatch</a>. Does no autodiscovery.
</p>
        </div>
      </div>


    </div>


  </div>


<div id="validator-badges">
  <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
</div>

</body>
</html>